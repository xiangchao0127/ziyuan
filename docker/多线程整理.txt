方法锁（synchronized修饰方法时） 是获取的类实例的”锁“

sleep 不会释放锁，让出cpu给其他线程    
wait会释放锁  进入等待此对象的等待锁定池 notify会唤醒一个等待的线程  
wait notify 必须在同步块中进行（或者ReentrantLock中的lock块中）

锁分类

乐观锁/悲观锁: 内存位置（V）、进行比较的预期原值（A）和拟写入的新值（B）  更新时如果A==V更新，否则重试（写多的话 耗CPU），适合多读 悲观锁适合写

独享锁/共享锁: 独享锁是指该锁一次只能被一个线程所持有 （ReadWriteLock，其读锁是共享锁，其写锁是独享锁）

互斥锁/读写锁:  独享锁/共享锁就是一种广义的说法，互斥锁/读写锁就是具体的实现。互斥锁在Java中的具体实现就是ReentrantLock。读写锁在Java中的具体实现就是ReadWriteLock。

可重入锁:  可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁 可重入锁的一个好处是可一定程度避免死锁

公平锁/非公平锁: 公平锁是指多个线程按照申请锁的顺序来获取锁。

分段锁: ConcurrentHashMap 分段锁的设计目的是细化锁的粒度
ConcurrentHashMap使用的锁分段技术。首先将数据分成一段一段地存储（segment），然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。

偏向锁/轻量级锁/重量级锁:
  偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。
  轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。
　重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让他申请的线程进入阻塞，性能降低。
自旋锁: 在Java中，自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU

synchronized  可重入锁，悲观锁，独享锁，非公平锁
ReetrantLock  独享锁 乐观锁 非公平锁（可配置） 非公平锁的优点在于吞吐量比公平锁大
锁必须是同一把才能生效
automic 原子类 基于CAS 线程安全

对于普通同步方法，锁是当前实例对象。
对于静态同步方法，锁是当前类的Class对象。
对于同步方法块，锁是Synchonized括号里配置的对象。
Java中的锁实现: 队列同步器AbstractQueuedSynchronizer（以下简称同步器 AQS），是用来构建锁或者其他同步组件的基础框架
CAS缺点
1.CAS长时间自旋不成功，给CPU带来很大的性能开销
2.只能保证一个共享变量的原子操作。对多个共享变量操作时，不能保证原子性。 解决方法：加锁；共享变量合并成一个共享变量
3.ABA的问题：线程将变量由A->B>A 导致A没有变  解决方法就是：增加版本号，每次使用的时候版本号+1，每次变量更新的时候版本号+1 java提供AtomicStampzedReference来解决ABA
ConcurrentHashMap 是乐观锁（读）实现   hashtable是悲观锁（写）实现

待学习 threadlocal countdownlatch automic 为何线程不安全，内存模型研究

java对象存储在堆（Heap）内存。那么一个Java对象到底包含什么呢？概括起来分为对象头(Mark Word 存锁的状态)、对象体和对齐字节。

对象的几个部分的作用：

1,2,3 是对象头
1.对象头中的Mark Word（标记字）主要用来表示对象的线程锁状态，另外还可以用来配合GC、存放该对象的hashCode；


2.Klass Word是一个指向方法区中Class信息的指针，意味着该对象可随时知道自己是哪个Class的实例；


3.数组长度也是占用64位（8字节）的空间，这是可选的，只有当本对象是一个数组对象时才会有这个部分；


4.对象体是用于保存对象属性和值的主体部分，占用内存空间取决于对象的属性数量和类型；


5.对齐字是为了减少堆内存的碎片空间（不一定准确）。




java关键字 sleep wait notify join 关键字解释demo

public class zonghe {
    public static void main(String[] args) throws InterruptedException {
        Object lockObj = new Object();
        CountThread countThread1 = new CountThread("1号计数器", lockObj);
        CountThread countThread2 = new CountThread("2号计数器", lockObj);
        CountThread countThread3 = new CountThread("3号计数器", lockObj);
        countThread1.start();
        countThread2.start();
        countThread3.start();
        new NotifyThread(lockObj).start();
        countThread1.join();
        countThread2.join();
        countThread3.join();
        System.out.println("kexinxin");
    }
}

class NotifyThread extends Thread {
    Object lockObj;
    public NotifyThread(Object lockObj) {
        this.lockObj = lockObj;
    }
    @Override
    public void run() {
        try {
            sleep(2000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        synchronized (lockObj) {
            System.out.println("notifyAll方法执行完毕");
            lockObj.notifyAll();
        }
    }
}

class CountThread extends Thread {
    Object lockObj;
    String threadName;
    public CountThread() {

    }
    public CountThread(String threadName, Object lockObj) {
        super(threadName);
        this.lockObj = lockObj;
    }
    @Override
    public void run() {
        int i = 1;
        synchronized (lockObj) {
            System.out.println(getName() + " : " + i);
            try {
                lockObj.wait();
                System.out.println(getName() + ":do something");
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}